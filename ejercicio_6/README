ğŸ² Juego de DominÃ³ en C++
Sistema completo de juego de dominÃ³ implementado con ProgramaciÃ³n Orientada a Objetos en C++.
ğŸ“‹ CaracterÃ­sticas

âœ… Soporte para 2-4 jugadores humanos
âœ… Sistema de puntuaciÃ³n y victorias
âœ… DistribuciÃ³n aleatoria de 28 fichas
âœ… Interfaz de consola intuitiva
âœ… DetecciÃ³n automÃ¡tica de bloqueos
âœ… MÃºltiples partidas sin reiniciar el programa
âœ… Manejo completo de casos especiales

ğŸ—ï¸ Estructura del CÃ³digo
Clase Ficha
Representa una ficha de dominÃ³ con dos valores numÃ©ricos.
Atributos:

lado1, lado2: Valores numÃ©ricos de cada extremo

MÃ©todos principales:

puedeConectar(int numero): Verifica si la ficha puede conectarse
obtenerLadoOpuesto(int lado): Devuelve el lado opuesto
voltear(): Intercambia los lados de la ficha
mostrar(): Visualiza la ficha en formato [X|Y]

Clase Jugador
Representa a un jugador con su estado y fichas.
Atributos:

nombre: Nombre del jugador
mano: Vector de fichas que posee
victorias: Contador de victorias acumuladas

MÃ©todos principales:

recibirFicha(Ficha): Agrega una ficha a la mano
jugarFicha(int indice): Remueve y devuelve una ficha
tieneFichaValida(extremoIzq, extremoDer): Verifica si puede jugar
calcularPuntosRestantes(): Suma los puntos de las fichas restantes

Clase JuegoDomino
Gestiona el flujo completo del juego.
Atributos:

jugadores: Vector de jugadores participantes
mesa: Vector de fichas colocadas
fichasDisponibles: Pool inicial de fichas
turnoActual: Ãndice del jugador en turno

MÃ©todos principales:

crearFichas(): Genera las 28 fichas del dominÃ³
mezclarFichas(): Aleatoriza el orden de las fichas
distribuirFichas(): Reparte fichas a los jugadores
jugarTurno(): Procesa el turno de un jugador
hayMovimientosPosibles(): Detecta bloqueos

ğŸ® Reglas del DominÃ³
Objetivo
Ser el primer jugador en colocar todas sus fichas o tener menos puntos en caso de bloqueo.
DistribuciÃ³n de Fichas

2 jugadores: 7 fichas cada uno
3 jugadores: 6 fichas cada uno
4 jugadores: 6 fichas cada uno

MecÃ¡nica del Juego

Primera jugada: El primer jugador coloca cualquier ficha en la mesa
Turnos siguientes: Los jugadores deben conectar una ficha con uno de los extremos disponibles
ConexiÃ³n: Los nÃºmeros deben coincidir (ej: [3|5] puede conectarse con un extremo que tenga 3 o 5)
Pasar turno: Si un jugador no tiene fichas vÃ¡lidas, pierde su turno
Victoria: El primer jugador en quedarse sin fichas gana
Bloqueo: Si nadie puede jugar, gana quien tenga menos puntos totales en sus fichas

Sistema de PuntuaciÃ³n

Cada victoria incrementa el contador de victorias del jugador
El marcador se mantiene entre mÃºltiples partidas

ğŸ”§ CompilaciÃ³n y EjecuciÃ³n
Requisitos

Compilador C++ compatible con C++11 o superior
Sistema operativo: Windows, Linux o macOS

CompilaciÃ³n
En Linux/macOS:
bashg++ -std=c++11 domino.cpp -o domino
./domino
En Windows (con MinGW):
bashg++ -std=c++11 domino.cpp -o domino.exe
domino.exe
En Windows (con Visual Studio):
bashcl /EHsc domino.cpp
domino.exe
Alternativa con Make
Puedes crear un archivo Makefile:
makefileCXX = g++
CXXFLAGS = -std=c++11 -Wall

domino: domino.cpp
	$(CXX) $(CXXFLAGS) domino.cpp -o domino

clean:
	rm -f domino
Luego ejecutar:
bashmake
./domino
ğŸ¯ GuÃ­a de Uso
1. Inicio del Juego
Al ejecutar el programa:

Ingresa el nÃºmero de jugadores (2-4)
Escribe el nombre de cada jugador

2. MenÃº Principal
Opciones disponibles:

1. Iniciar Nueva Partida: Comienza una nueva ronda
2. Salir: Cierra el programa

3. Durante la Partida
VisualizaciÃ³n
El juego muestra:

Estado actual de la mesa
Extremos disponibles para conectar
Tu mano de fichas numeradas

Tu Turno

Selecciona el nÃºmero de la ficha que deseas jugar (1-N)
Si la ficha puede conectarse en ambos extremos, elige lado (1=Izquierda, 2=Derecha)
La ficha se coloca automÃ¡ticamente en la orientaciÃ³n correcta

Casos Especiales

Sin fichas vÃ¡lidas: El turno se pasa automÃ¡ticamente
Victoria: El juego termina cuando alguien se queda sin fichas
Bloqueo: Si nadie puede jugar, gana quien tenga menos puntos

4. DespuÃ©s de la Partida

Se muestra el marcador general con las victorias de cada jugador
Puedes iniciar una nueva partida desde el menÃº

ğŸ’¡ Ejemplos de Juego
Ejemplo 1: Primera Jugada
MESA DE JUEGO
(Mesa vacÃ­a - Primera jugada)

Jugador 1 - Fichas (7):
  1. [3|5]
  2. [2|4]
  3. [6|6]
  ...

Selecciona la ficha (1-7): 1
Ejemplo 2: Jugada Intermedia
MESA DE JUEGO
[3|5] [5|2] [2|6]
Extremos disponibles: [3] ... [6]

Jugador 2 - Fichas (5):
  1. [3|4]  â† Puede conectarse con [3]
  2. [1|2]
  3. [6|5]  â† Puede conectarse con [6]
  ...

Selecciona la ficha (1-5): 1
Â¿DÃ³nde colocar? (1=Izquierda, 2=Derecha): 1
Ejemplo 3: Victoria
Ficha colocada exitosamente.

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          Â¡Ana HA GANADO LA PARTIDA!                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MARCADOR GENERAL
Ana: 1 victoria(s)
Juan: 0 victoria(s)
ğŸ› ï¸ Principios de POO Aplicados
âœ… EncapsulaciÃ³n

Atributos privados y protegidos con acceso controlado mediante getters
ValidaciÃ³n de datos en los mÃ©todos pÃºblicos
Ocultamiento de implementaciÃ³n interna

âœ… Herencia

Clase Base Abstracta Participante: Define interfaz comÃºn para todos los jugadores
Clase Derivada JugadorHumano: Hereda de Participante, implementa comportamiento para jugadores humanos
Clase Derivada JugadorIA: Hereda de Participante, implementa comportamiento para IA con 3 niveles
ReutilizaciÃ³n de cÃ³digo mediante herencia de atributos y mÃ©todos comunes

âœ… Polimorfismo
MÃ©todos Virtuales:

decidirJugada(): MÃ©todo virtual puro que cada tipo de jugador implementa de forma diferente
getTipo(): MÃ©todo virtual que identifica el tipo de participante
mostrarMano(): MÃ©todo virtual que se comporta diferente segÃºn el tipo (Humano muestra fichas, IA las oculta)

Sobrecarga de Operadores:

operator==: Compara fichas
operator<: Ordena fichas por puntos
operator<<: Imprime fichas en streams

Polimorfismo en Tiempo de EjecuciÃ³n:

Vector de shared_ptr<Participante> que almacena diferentes tipos de jugadores
El mismo cÃ³digo funciona para humanos e IAs gracias al polimorfismo

AbstracciÃ³n

Interfaces limpias que ocultan la complejidad interna
SeparaciÃ³n clara de responsabilidades entre clases

Modularidad

Cada clase tiene una responsabilidad especÃ­fica
Bajo acoplamiento entre componentes

ğŸ› Manejo de Errores
El programa incluye manejo robusto de:

âœ… Entradas invÃ¡lidas del usuario
âœ… Ãndices fuera de rango
âœ… Movimientos ilegales
âœ… Estados de bloqueo
âœ… ValidaciÃ³n de datos de entrada

ğŸ“Š CaracterÃ­sticas TÃ©cnicas

Lenguaje: C++11 o superior
Paradigma: ProgramaciÃ³n Orientada a Objetos
Aleatoriedad: std::random_device y std::mt19937
Estructuras de datos: std::vector
Complejidad: O(n) para la mayorÃ­a de operaciones

ğŸ”„ Flujo del Programa
Inicio
  â†“
Configurar Jugadores
  â†“
MenÃº Principal â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â†“                        â”‚
Iniciar Partida           â”‚
  â†“                        â”‚
Crear y Mezclar Fichas    â”‚
  â†“                        â”‚
Distribuir Fichas         â”‚
  â†“                        â”‚
Bucle de Turnos â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â†“                        â”‚
Â¿Victoria o Bloqueo? â”€Noâ”€â”€â”˜
  â†“ SÃ­
Mostrar Ganador
  â†“
Actualizar Marcador
  â†“
Volver al MenÃº
ğŸ“ Notas Importantes

Interfaz en Consola: La visualizaciÃ³n estÃ¡ optimizada para terminales con soporte UTF-8
Sistema de Puntos: En caso de bloqueo, se suman los valores de todas las fichas restantes
MÃºltiples Partidas: Las victorias se acumulan sin necesidad de reiniciar
ValidaciÃ³n: Todos los movimientos son validados antes de ejecutarse

ğŸ“ PropÃ³sito Educativo
Este proyecto demuestra:

DiseÃ±o de clases y relaciones
GestiÃ³n de estado del juego
ImplementaciÃ³n de reglas de negocio
InteracciÃ³n con usuario mediante consola
GeneraciÃ³n y manejo de aleatoriedad
Estructuras de datos dinÃ¡micas

ğŸ“„ Licencia
Proyecto educativo desarrollado para propÃ³sitos acadÃ©micos.

Â¡Disfruta del juego! ğŸ²